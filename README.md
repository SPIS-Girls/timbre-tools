# Timbre Toys
### Timbre Tools Hackathon 2024

This repository contains source code and assets of the project made by **SPIS Girls** for Timbre Tools 2024 Hackathon.

## What is the project about?
### Inspiration
The project comes in the form of a Max Patch. It is a **timbre** manipulation tool that allows the users to interact with a timbre the same way they would interact with a physical object. The main inspiration behind the project was a sonic interaction and a live performance (_#sensingtimbre_, _#timbrecheck_, _#timbreforall_).

### Technical Overview
The way the audio is modified depends on a camera input. More specifically, the tool extracts visual properties of the live video feed from the webcam (color space, brightness, presence and a full spectogram). The intensity of the extracted features controls timbre-manipulating audio effects. Additionally, audio input is convolved with the camera input, adding unpredictable factor to the whole system.

Video feature extraction and FFT calculations are computed in a real-time JUCE plugin. The plugin is plugged into the MaxMSP Patch. In the patch, certain effects and their parameters are controlled by the values generated by the JUCE plugin.

| <figure style="display:flex;align-items:center"> <img src="/images/schema.jpg" alt="Project Schema" width="70%"></figure> | üèµÔ∏è - Predictable Timbre Componenets <br> ‚≠ê - Magic Frequency Computation |
| -------- | ------- |

## In-Depth Description

### Feature Extraction
The JUCE plugin is responsible for every image-dependent feature extraction. It periodically caputres a still image from the first available webcam and process it. The images is copied and resized over more manageable and writable data structures. The features are programatically extracted. Some of them are individual color presence (bleeding amount) and slinkiness (expansion of the slinky). The image is then resized one more time and fed to another object, which will run a FFT on the image itself.
##### Video Capture  
Each incoming frame is first resized to size NxN (where N is a power of 2) and then its 2D FFT is calculated.
### FFT Calculations
A simple prototype of the algorithm can be found in [python_test](/python_test) directory.
##### FFT Audio Processing
In the audio processing loop, samples are grouped into blocks of size N. For each block its 1D FFT is calculated. Image FFT and audio FFT are then combined by running an element-wise multiplication. The resulting 2D signal is extracted by running 2D IFFT. To move from 2D to 1D, the sum of each column is calculated. The resulting 1D signal is then scaled to a range [-1;1] and multiplied by a Hann window of size N to minimize artifacts.  
### JUCE -> MaxMSP Communication
After extracting features from the video stream, JUCE passes audio and MIDI messages into Max using the Max object ~vst. Each of the extracted features are mapped to an audio effect parameter from Max's built-in audio effects.
### MaxMSP
The MIDI messages that are passed to Max are from the extracted video features: red content, green content, blue content, presence, crunchiness, and brightness. Due to time contraints in the hackathon, only red, blue, green, and presence were mapped to following audio effects.

Red: Wet/dry mix of a rain drop synthesizer. This effect takes a given audio and makes it sound like falling drops. A wetter mix makes the audio sound more raindrop-like.
Green: Offset of "Comber," a comb filter effect.
Blue: Wet/dry mix of a chamber reverb effect.
Presence: Transposition of a pitch shifter effect. More succinctly, the presence of the slinky bends the pitch. 

All of the audio effects controlled by the incoming MIDI messages are multiplied with the original audio signal, creating a beautiful cocophony of music controlled by the webcam watching the slinky. 

## Meet The Team
We are a team of 5 from Sound and Music Computing, Aalborg University:
| Cumhur | Giacomo | Kate | Levin | Maria |
| -------- | ------- | ------- | ------- | ------- |
| <figure><img src="/images/C.png" width="100"></figure>  | <figure> <img src="/images/G.png" width="100"></figure> | <figure> <img src="/images/K.png" width="100"></figure> | <figure> <img src="/images/L.png" width="100"></figure> | <figure> <img src="/images/M.png" width="100"></figure> |

